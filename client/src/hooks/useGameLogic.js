import { useState, useCallback, useEffect, useRef } from 'react';
import socket from '../socket';

export const useGameLogic = (roomId, gameState, updateGameState) => {
  const [diceState, setDiceState] = useState({
    isRolling: false,
    displayDice: 0,
    displayD1: 0,
    displayD2: 0,
    lastRoll: 0,
    timerDice: 0 // –ó–Ω–∞—á–µ–Ω–∏–µ –∫—É–±–∏–∫–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ —Ç–∞–π–º–µ—Ä–µ (—Å –∑–∞–¥–µ—Ä–∂–∫–æ–π)
  });

  const [turnTimerState, setTurnTimerState] = useState({
    timer: 120,
    isActive: false
  });

  const [gameStartTime, setGameStartTime] = useState(null);
  const [gameStats, setGameStats] = useState({
    dealsCompleted: 0,
    passiveIncome: 0,
    finalNetWorth: 0
  });

  const audioRef = useRef(null);
  const timerIntervalRef = useRef(null);

  // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—É–¥–∏–æ
  useEffect(() => {
    try {
      audioRef.current = new Audio();
      audioRef.current.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBSuBzvLZiTYIG2m98OScTgwOUarm7blmGgU7k9n1unEiBC13yO/eizEIHWq+8+OWT';
    } catch (error) {
      console.warn('Audio not supported:', error);
    }
  }, []);

  // –ó–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞ –∏–≥—Ä—ã
  useEffect(() => {
    if (gameState.isMyTurn && !gameStartTime) {
      setGameStartTime(Date.now());
    }
  }, [gameState.isMyTurn, gameStartTime]);

  // –°–ª—É—à–∞–µ–º —Å–µ—Ä–≤–µ—Ä–Ω—ã–µ —Å–æ–±—ã—Ç–∏—è —Ç–∞–π–º–µ—Ä–∞
  useEffect(() => {
    const handleTurnTimerUpdate = (data) => {
      console.log('‚è∞ [useGameLogic] Turn timer update:', data);
      setTurnTimerState({
        timer: data.remaining,
        isActive: data.isActive,
        paused: data.paused || false
      });
      
      // –ó–≤—É–∫–æ–≤—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
      if (data.remaining === 10 && audioRef.current && gameState.isMyTurn) {
        try {
          audioRef.current.play().catch(e => console.log('–ù–µ —É–¥–∞–ª–æ—Å—å –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ—Å—Ç–∏ –∑–≤—É–∫:', e));
        } catch (error) {
          console.warn('Audio play failed:', error);
        }
      }
    };

    socket.on('turnTimerUpdate', handleTurnTimerUpdate);

    return () => {
      socket.off('turnTimerUpdate', handleTurnTimerUpdate);
    };
  }, [gameState.isMyTurn]);

  // –°–±—Ä–æ—Å —Ç–∞–π–º–µ—Ä–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ —Ö–æ–¥–∞
  useEffect(() => {
    if (gameState.isMyTurn) {
      setTurnTimerState({ timer: 120, isActive: true });
      console.log('‚è∞ [useGameLogic] –¢–∞–π–º–µ—Ä –∑–∞–ø—É—â–µ–Ω –¥–ª—è –∏–≥—Ä–æ–∫–∞:', gameState.myId);
    } else {
      setTurnTimerState({ timer: 120, isActive: false });
      console.log('‚è∏Ô∏è [useGameLogic] –¢–∞–π–º–µ—Ä –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
    }
  }, [gameState.isMyTurn, gameState.myId]);

  // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –∑–∞–ø—É—Å–∫ —Ç–∞–π–º–µ—Ä–∞ –ø—Ä–∏ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –∏–≥—Ä—ã
  useEffect(() => {
    if (gameState.players && gameState.players.length > 0 && !gameState.isMyTurn) {
      // –ï—Å–ª–∏ –µ—Å—Ç—å –∏–≥—Ä–æ–∫–∏, –Ω–æ —Ö–æ–¥ –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω, –Ω–∞–∑–Ω–∞—á–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞
      const firstPlayer = gameState.players[0];
      if (firstPlayer && firstPlayer.id === gameState.myId) {
        console.log('üéØ [useGameLogic] –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –Ω–∞–∑–Ω–∞—á–∞–µ–º –ø–µ—Ä–≤–æ–≥–æ –∏–≥—Ä–æ–∫–∞:', firstPlayer.username);
        // –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è gameState
      }
    }
  }, [gameState.players, gameState.myId, gameState.isMyTurn]);

  // –ë—Ä–æ—Å–æ–∫ –∫—É–±–∏–∫–æ–≤
  const rollDice = useCallback(() => {
    if (diceState.isRolling || !gameState.isMyTurn) return;

    setDiceState(prev => ({ ...prev, isRolling: true }));

    // –ê–Ω–∏–º–∞—Ü–∏—è –±—Ä–æ—Å–∫–∞
    const rollAnimation = setInterval(() => {
      setDiceState(prev => ({
        ...prev,
        displayD1: Math.floor(Math.random() * 6) + 1,
        displayD2: Math.floor(Math.random() * 6) + 1,
        displayDice: Math.floor(Math.random() * 6) + 1
      }));
    }, 100);

    // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –∞–Ω–∏–º–∞—Ü–∏—é —á–µ—Ä–µ–∑ 1 —Å–µ–∫—É–Ω–¥—É
    setTimeout(() => {
      clearInterval(rollAnimation);
      
      // –§–∏–Ω–∞–ª—å–Ω—ã–π –±—Ä–æ—Å–æ–∫
      const d1 = Math.floor(Math.random() * 6) + 1;
      const d2 = Math.floor(Math.random() * 6) + 1;
      const total = d1 + d2;
      
      setDiceState(prev => ({
        ...prev,
        isRolling: false,
        displayDice: total,
        displayD1: d1,
        displayD2: d2,
        lastRoll: total
      }));

      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –Ω–∞ —Å–µ—Ä–≤–µ—Ä
      socket.emit('rollDice', roomId, gameState.myId, total);
      
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
      updateGameState({ dice: total });

      // –ü–µ—Ä–µ–Ω–æ—Å–∏–º –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É–±–∏–∫–∞ –≤ —Ç–∞–π–º–µ—Ä —á–µ—Ä–µ–∑ 2 —Å–µ–∫—É–Ω–¥—ã
      setTimeout(() => {
        setDiceState(prev => ({
          ...prev,
          timerDice: total
        }));
        console.log('üé≤ [useGameLogic] –ü–µ—Ä–µ–Ω–µ—Å–ª–∏ –∑–Ω–∞—á–µ–Ω–∏–µ –∫—É–±–∏–∫–∞ –≤ —Ç–∞–π–º–µ—Ä:', total);
      }, 2000);
    }, 1000);
  }, [diceState.isRolling, gameState.isMyTurn, gameState.myId, roomId, updateGameState]);

  // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Ö–æ–¥–∞
  const handleEndTurn = useCallback(() => {
    if (!gameState.isMyTurn) return;
    
    console.log('üîÑ [GameLogic] Ending turn for player:', gameState.myId);
    socket.emit('endTurn', roomId, gameState.myId);
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ö–æ–¥–∞
    updateGameState({ isMyTurn: false });
    setTurnTimerState({ timer: 120, isActive: false });
  }, [gameState.isMyTurn, gameState.myId, roomId, updateGameState]);

  // –ü–µ—Ä–µ–¥–∞—á–∞ –¥–µ–Ω–µ–≥
  const handleTransferMoney = useCallback((toPlayerId, amount) => {
    if (!toPlayerId || amount <= 0) return;
    
    console.log('üîÑ [GameLogic] Transferring money:', { toPlayerId, amount });
    socket.emit('transferMoney', roomId, gameState.myId, toPlayerId, amount);
  }, [roomId, gameState.myId]);

  // –ü–æ–∫—É–ø–∫–∞ —Å–¥–µ–ª–∫–∏
  const handleBuyDeal = useCallback((card, useCredit = false) => {
    if (!card) return;
    
    console.log('üîÑ [GameLogic] Buying deal:', { card, useCredit });
    socket.emit('buyDeal', roomId, gameState.myId, card, useCredit);
    
    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä—ã
    setGameStats(prev => ({
      ...prev,
      dealsCompleted: prev.dealsCompleted + 1
    }));
  }, [roomId, gameState.myId]);

  // –û—Ç–∫–∞–∑ –æ—Ç —Å–¥–µ–ª–∫–∏
  const handleSkipDeal = useCallback((card) => {
    if (!card) return;
    
    console.log('üîÑ [GameLogic] Skipping deal:', card);
    socket.emit('skipDeal', roomId, gameState.myId, card);
  }, [roomId, gameState.myId]);

  // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∏–≥—Ä—ã
  const handleGameEnd = useCallback(async (won = false) => {
    if (!gameStartTime) return;
    
    const gameTime = Math.round((Date.now() - gameStartTime) / 60000); // –≤ –º–∏–Ω—É—Ç–∞—Ö
    const currentPlayer = getCurrentPlayer();
    
    if (!currentPlayer) return;
    
    // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–∞
    const gameData = {
      roomId,
      playerId: gameState.myId,
      username: currentPlayer.username,
      finalScore: currentPlayer.balance + currentPlayer.passiveIncome,
      finalNetWorth: currentPlayer.balance,
      gameTime,
      dealsCompleted: gameStats.dealsCompleted,
      passiveIncome: currentPlayer.passiveIncome,
      won
    };
    
    console.log('üîÑ [GameLogic] Game ended, updating rating:', gameData);
    
    try {
      // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –Ω–∞ —Å–µ—Ä–≤–µ—Ä –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Ä–µ–π—Ç–∏–Ω–≥–∞
      const response = await fetch('http://localhost:5000/api/ratings/update', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(gameData),
      });
      
      if (response.ok) {
        console.log('‚úÖ [GameLogic] Rating updated successfully');
      } else {
        console.error('‚ùå [GameLogic] Failed to update rating');
      }
    } catch (error) {
      console.error('‚ùå [GameLogic] Error updating rating:', error);
    }
    
    // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏–≥—Ä—ã
    setGameStats({
      dealsCompleted: 0,
      passiveIncome: 0,
      finalNetWorth: 0
    });
    setGameStartTime(null);
  }, [gameStartTime, gameState.myId, roomId, gameStats]);

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ç–µ–∫—É—â–µ–º –∏–≥—Ä–æ–∫–µ
  const getCurrentPlayer = useCallback(() => {
    return gameState.players.find(p => p.id === gameState.myId);
  }, [gameState.players, gameState.myId]);

  // –ü—Ä–æ–≤–µ—Ä–∫–∞, –º–æ–∂–µ—Ç –ª–∏ –∏–≥—Ä–æ–∫ –ø–æ–∑–≤–æ–ª–∏—Ç—å —Å–µ–±–µ –ø–æ–∫—É–ø–∫—É
  const canAffordPurchase = useCallback((cost) => {
    const currentPlayer = getCurrentPlayer();
    if (!currentPlayer) return false;
    
    return currentPlayer.balance >= cost;
  }, [getCurrentPlayer]);

  // –†–∞—Å—á–µ—Ç –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ –∫—Ä–µ–¥–∏—Ç–∞
  const calculateMaxLoan = useCallback(() => {
    const currentPlayer = getCurrentPlayer();
    if (!currentPlayer) return 0;
    
    return currentPlayer.monthlyCashflow * 10;
  }, [getCurrentPlayer]);

  // –†–∞—Å—á–µ—Ç –¥–æ—Å—Ç—É–ø–Ω–æ–≥–æ –∫—Ä–µ–¥–∏—Ç–∞ –¥–ª—è –ø–æ–∫—É–ø–∫–∏
  const calculateAvailableCredit = useCallback((cost) => {
    const currentPlayer = getCurrentPlayer();
    if (!currentPlayer) return { fromBalance: 0, fromCredit: 0 };
    
    const maxFromBalance = Math.floor(currentPlayer.balance / 1000) * 1000;
    const fromBalance = Math.min(maxFromBalance, cost);
    const fromCredit = cost - fromBalance;
    
    return { fromBalance, fromCredit };
  }, [getCurrentPlayer]);

  // –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–≥—Ä–æ–∫–æ–≤ –¥–ª—è –ø–µ—Ä–µ–≤–æ–¥–∞ (—Ç–æ–ª—å–∫–æ –∏–∑ —Ç–µ–∫—É—â–µ–π –∫–æ–º–Ω–∞—Ç—ã)
  const getTransferablePlayers = useCallback(() => {
    return gameState.players.filter(p => 
      p.id !== gameState.myId && 
      p.roomId === roomId
    );
  }, [gameState.players, gameState.myId, roomId]);

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Å—Å–∏–≤–Ω–æ–≥–æ –¥–æ—Ö–æ–¥–∞
  const updatePassiveIncome = useCallback((newPassiveIncome) => {
    setGameStats(prev => ({
      ...prev,
      passiveIncome: newPassiveIncome
    }));
  }, []);

  // –§—É–Ω–∫—Ü–∏–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ç–∞–π–º–µ—Ä–æ–º –¥–ª—è —Ö–æ—Å—Ç–∞
  const pauseTurnTimer = useCallback(() => {
    if (roomId) {
      console.log('‚è∏Ô∏è [useGameLogic] Pausing turn timer');
      socket.emit('pauseTurnTimer', roomId);
    }
  }, [roomId]);

  const resumeTurnTimer = useCallback(() => {
    if (roomId) {
      console.log('‚ñ∂Ô∏è [useGameLogic] Resuming turn timer');
      socket.emit('resumeTurnTimer', roomId);
    }
  }, [roomId]);

  return {
    // –°–æ—Å—Ç–æ—è–Ω–∏–µ
    diceState,
    turnTimerState,
    gameStats,
    
    // –î–µ–π—Å—Ç–≤–∏—è
    rollDice,
    handleEndTurn,
    handleTransferMoney,
    handleBuyDeal,
    handleSkipDeal,
    handleGameEnd,
    updatePassiveIncome,
    pauseTurnTimer,
    resumeTurnTimer,
    
    // –£—Ç–∏–ª–∏—Ç—ã
    getCurrentPlayer,
    canAffordPurchase,
    calculateMaxLoan,
    calculateAvailableCredit,
    getTransferablePlayers
  };
};
